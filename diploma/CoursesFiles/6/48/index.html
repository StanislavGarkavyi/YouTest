<p>Паттерн Прототип (Prototype) позволяет создавать объекты на основе уже ранее созданных объектов-прототипов. То есть по сути данный паттерн предлагает технику клонирования объектов.</p>
<p><b>Когда использовать Прототип?</b></p>
<ul>
    <li>Когда конкретный тип создаваемого объекта должен определяться динамически во время выполнения</li>
    <li>Когда нежелательно создание отдельной иерархии классов фабрик для создания объектов-продуктов из параллельной иерархии классов (как это делается, например, при использовании паттерна Абстрактная фабрика)</li>
    <li>Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация с помощью конструктора. Особенно когда известно, что объект может принимать небольшое ограниченное число возможных состояний.</li>
</ul>
<p>На языке UML отношения между классами при применении данного паттерна можно описать следующим образом:</p>
<img src="../../CoursesFiles/6/48/img/1.jpg">
<p>Формальная структура паттерна на C# могла бы выглядеть следующим образом:</p>
<img src="../../CoursesFiles/6/48/img/2.jpg"><br>
<img src="../../CoursesFiles/6/48/img/3.jpg">
<p><b>Участники</b></p>
<ul>
    <li>Prototype: определяет интерфейс для клонирования самого себя, который, как правило, представляет метод Clone()</li>
    <li>ConcretePrototype1 и ConcretePrototype2: конкретные реализации прототипа. Реализуют метод Clone()</li>
    <li>Client: создает объекты прототипов с помощью метода Clone()</li>
</ul>
<p>Рассмотрим клонирование на примере фигур - прямоугольников и кругов:</p><br>
<img src="../../CoursesFiles/6/48/img/4.jpg"><br>
<img src="../../CoursesFiles/6/48/img/5.jpg"><br>
<img src="../../CoursesFiles/6/48/img/6.jpg"><br>
<img src="../../CoursesFiles/6/48/img/7.jpg"><br>
<p>Здесь в качестве прототипа используется интерфейс IFigure, который реализуется классами Circle и Rectangle.</p>
<p>Но в данном случае надо заметить, что фреймворк .NET предлагает функционал для копирования в виде метода MemberwiseClone(). Например, мы могли бы изменить реализацию метода Clone() в классах прямоугольника и круга следующим образом:</p>
<img src="../../CoursesFiles/6/48/img/8.jpg">
<p>Причем данный метод был бы общим для обоих классов. И работа программы никак бы не изменилась.</p>
<p>В то же время надо учитывать, что метод MemberwiseClone() осуществляет неполное копирование - то есть копирование значимых типов. Если же класс фигуры содержал бы объекты ссылочных типов, то оба объекта после клонирования содержали бы ссылку на один и тот же ссылочный объект. Например, пусть фигура круг имеет свойство ссылочного типа:</p>
<br>
<img src="../../CoursesFiles/6/48/img/9.jpg"><br>
<img src="../../CoursesFiles/6/48/img/10.jpg"><br>
<p>В этом случае при изменении значений в свойстве Point начальной фигуры автоматически бы изменилось соответствующее значение и у клонированной фигуры:</p>
<img src="../../CoursesFiles/6/48/img/11.jpg">
<p>Чтобы избежать подобной ситуации, надо применить полное копирование:</p>
<br>
<img src="../../CoursesFiles/6/48/img/12.jpg"><br>
<img src="../../CoursesFiles/6/48/img/13.jpg"><br>
<img src="../../CoursesFiles/6/48/img/14.jpg"><br>
<img src="../../CoursesFiles/6/48/img/15.jpg"><br>
<p>Чтобы вручную не создавать у клонированного объекта вложенный объект Point, здесь используются механизмы бинарной сериализации. И в этом случае все классы, объекты которых подлежат копированию, должны быть помечены атрибутом Serializable.</p>
<style>p{text-indent: 25px;}</style>