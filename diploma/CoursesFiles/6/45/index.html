<p>Фабричный метод (Factory Method) - это паттерн, который определяет интерфейс для создания объектов некоторого класса, но непосредственное решение о том, объект какого класса создавать происходит в подклассах. То есть паттерн предполагает, что базовый класс делегирует создание объектов классам-наследникам.<p>
<p><b>Когда надо применять паттерн</b><p>
<ul>
    <li>Когда заранее неизвестно, объекты каких типов необходимо создавать</li>
    <li>Когда система должна быть независимой от процесса создания новых объектов и расширяемой: в нее можно легко вводить новые классы, объекты которых система должна создавать.</li>
    <li>Когда создание новых объектов необходимо делегировать из базового класса классам наследникам</li>
</ul>
<p>На языке UML паттерн можно описать следующим образом:<p>
<img src="../../CoursesFiles/6/45/img/1.jpg">
<p>Формальное определение паттерна на языке C# может выглядеть следующим образом:<p>
<br>
<img src="../../CoursesFiles/6/45/img/2.jpg"> <br>
<img src="../../CoursesFiles/6/45/img/3.jpg">
<p><b>Участники</b><p>
<ul>
    <li>Абстрактный класс Product определяет интерфейс класса, объекты которого надо создавать.</li>
    <li>Конкретные классы ConcreteProductA и ConcreteProductB представляют реализацию класса Product. Таких классов может быть множество</li>
    <li>Абстрактный класс Creator определяет абстрактный фабричный метод FactoryMethod(), который возвращает объект Product.</li>
    <li>Конкретные классы ConcreteCreatorA и ConcreteCreatorB - наследники класса Creator, определяющие свою реализацию метода FactoryMethod(). Причем метод FactoryMethod() каждого отдельного класса-создателя возвращает определенный конкретный тип продукта. Для каждого конкретного класса продукта определяется свой конкретный класс создателя.</li>
</ul>
<p>Таким образом, класс Creator делегирует создание объекта Product своим наследникам. А классы ConcreteCreatorA и ConcreteCreatorB могут самостоятельно выбирать какой конкретный тип продукта им создавать.<p>
<p>Теперь рассмотрим на реальном примере. Допустим, мы создаем программу для сферы строительства. Возможно, вначале мы захотим построить многоэтажный панельный дом. И для этого выбирается соответствующий подрядчик, который возводит каменные дома. Затем нам захочется построить деревянный дом и для этого также надо будет выбрать нужного подрядчика:<p>
<br>
<img src="../../CoursesFiles/6/45/img/4.jpg"><br>
<img src="../../CoursesFiles/6/45/img/5.jpg"><br>
<img src="../../CoursesFiles/6/45/img/6.jpg"><br>
<img src="../../CoursesFiles/6/45/img/7.jpg">
<p>В качестве абстрактного класса Product здесь выступает класс House. Его две конкретные реализации - PanelHouse и WoodHouse представляют типы домов, которые будут строить подрядчики. В качестве абстрактного класса создателя выступает Developer, определяющий абстрактный метод Create(). Этот метод реализуется в классах-наследниках WoodDeveloper и PanelDeveloper. И если в будущем нам потребуется построить дома какого-то другого типа, например, кирпичные, то мы можем с легкостью создать новый класс кирпичных домов, унаследованный от House, и определить класс соответствующего подрядчика. Таким образом, система получится легко расширяемой. Правда, недостатки паттерна тоже очевидны - для каждого нового продукта необходимо создавать свой класс создателя.</p>
<style>
    p{text-indent: 25px;}
</style>